#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>
#include "../zmk-nodefree-config/helper.h"


/* use helper macros to define left and right hand keys */
#include "../../../../zmk-nodefree-config/keypos_def/keypos_36keys.h"       // keyposition helpers
#define KEYS_L LT0 LT1 LT2 LT3 LT4 LM0 LM1 LM2 LM3 LM4 LB0 LB1 LB2 LB3 LB4  // left-hand keys
#define KEYS_R RT0 RT1 RT2 RT3 RT4 RM0 RM1 RM2 RM3 RM4 RB0 RB1 RB2 RB3 RB4  // right-hand keys
#define THUMBS LH2 LH1 LH0 RH0 RH1 RH2                                      // thumb keys

/* left-hand HRMs */
ZMK_BEHAVIOR(hml, hold_tap,
    flavor = "balanced";
    tapping-term-ms = <280>;
    quick-tap-ms = <175>;                // repeat on tap-into-hold
    global-quick-tap-ms = <150>;         // requires PR #1387
    bindings = <&kp>, <&kp>;
    hold-trigger-key-positions = <KEYS_R THUMBS>;
    hold-trigger-on-release;             // delay positional check until key-release
)

/* right-hand HRMs */
ZMK_BEHAVIOR(hmr, hold_tap,
    flavor = "balanced";
    tapping-term-ms = <280>;
    quick-tap-ms = <175>;                // repeat on tap-into-hold
    global-quick-tap-ms = <150>;         // requires PR #1387
    bindings = <&kp>, <&kp>;
    hold-trigger-key-positions = <KEYS_L THUMBS>;
    hold-trigger-on-release;             // delay positional check until key-release
)

&mt {
  quick-tap-ms = <200>;
};

/ {
  conditional_layers {
    compatible = "zmk,conditional-layers";
    tri_layer {
      if-layers = <1 2>;
      then-layer = <3>;
    };
  };
  keymap {
    compatible = "zmk,keymap";
    default_layer {
      bindings = <
        &kp Q       &kp W       &kp E        &kp R         &kp T     &kp Y       &kp U          &kp I            &kp O         &kp P
        &kp A       &kp S       &kp D        &kp F         &kp G     &kp H       &kp J          &kp K            &kp L         &kp SEMI
        &hml LGUI Z &hml LALT X &hml LCTRL C &hml LSHFT V  &kp B     &kp N       &hmr RSHFT M   &hmr LCTRL COMMA &hmr LALT DOT &hmr LGUI FSLH
                                &mt LALT TAB &mt LGUI BSPC &lt 2 ESC &lt 1 ENTER &mt LSFT SPACE &trans
      >;
    };

    num_layer {
      bindings = <
        &kp F1         &kp F2       &kp F3          &kp F4          &kp F5    &kp F6    &kp F7          &kp F8          &kp F9         &kp F10
        &kp N1         &kp N2       &kp N3          &kp N4          &kp N5    &kp N6    &kp N7          &kp N8          &kp N9         &kp N0
        &hml LGUI EXCL &hml LALT AT &hml LCTRL HASH &hml LSHFT DLLR &kp PRCNT &kp CARET &hmr RSHFT AMPS &hmr LCTRL STAR &hmr LALT LPAR &hmr LGUI RPAR
                                    &trans          &trans          &trans    &trans    &trans          &trans
      >;
    };

    arw_layer {
      bindings = <
        &kp TAB         &kp INS         &kp LBRC        &kp RBRC        &kp LS(NON_US_HASH) &kp HOME  &kp PG_DN        &kp PG_UP        &kp END         &kp PSCRN
        &kp NON_US_BSLH &kp DEL         &kp LBKT        &kp RBKT        &kp NON_US_HASH     &kp LEFT  &kp DOWN         &kp UP           &kp RIGHT       &kp SQT
        &kp LGUI        &hml LALT GRAVE &hml LCTRL LPAR &hml LSHFT RPAR &kp PIPE2           &kp MINUS &hmr RSHFT UNDER &hmr LCTRL EQUAL &hmr LALT PLUS  &hmr LGUI NON_US_HASH
                                        &trans          &trans          &trans              &trans    &trans           &trans
      >;
    };

    ctl_layer {
      bindings = <
        &kp F11   &kp F12  &kp K_MUTE &kp K_PP   &kp K_VOL_UP &kp C_BRI_UP &none        &none        &none        &bt BT_CLR
        &kp LSHFT &kp LALT &kp K_PREV &kp K_NEXT &kp K_VOL_DN &kp C_BRI_DN &out OUT_BLE &out OUT_USB &none        &none
        &kp LGUI  &kp LALT &kp LCTRL  &kp LSHFT  &none        &bt BT_SEL 1 &bt BT_SEL 2 &bt BT_SEL 3 &bt BT_SEL 4 &bt BT_SEL 5
                           &trans     &trans     &trans       &trans       &trans       &trans
      >;
    };
  };
};
